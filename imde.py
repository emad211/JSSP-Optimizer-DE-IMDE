# -*- coding: utf-8 -*-
"""IMDE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LW1W_MWYy04TFQH9tkc9Eh59H0KdrWVs
"""

import random
import math
import numpy as np
import statistics
import time

class JSSPInstance:
    def __init__(self, file_path):
        with open(file_path, 'r') as f:
            line = f.readline().strip().split()
            self.n, self.m = int(line[0]), int(line[1])
            self.jobs = []
            for _ in range(self.n):
                arr = list(map(int, f.readline().strip().split()))
                ops = [(arr[2*i], arr[2*i+1]) for i in range(self.m)]
                self.jobs.append(ops)
        self.total_ops = self.n*self.m

class Individual:
    def __init__(self, float_vec, permutation, F, CR):
        self.float_vec = float_vec
        self.permutation = permutation
        self.F = F
        self.CR = CR
        self.makespan = None

class Archive:
    def __init__(self, capacity):
        self.capacity = capacity
        self.data = []
    def add(self, vec):
        if len(self.data) < self.capacity:
            self.data.append(vec)
        else:
            idx = random.randint(0, self.capacity-1)
            self.data[idx] = vec
    def get_random(self):
        if len(self.data) == 0:
            return None
        return random.choice(self.data)

class IMDEPopulation:
    def __init__(self, size, instance, process_type=1, p_rate=0.1):
        self.size = size
        self.instance = instance
        self.process_type = process_type
        self.p_rate = p_rate
        self.individuals = []
        self.F_mean = 0.7
        self.CR_mean = 0.7
        self.archive = Archive(self.size)
        self.initialize()

    def initialize(self):
        for _ in range(self.size):
            vec = [random.uniform(0, self.instance.total_ops-1) for _ in range(self.instance.total_ops)]
            vec = self.bound_handling(vec)
            perm = self.repair(vec)
            F_init = random.uniform(0.4,0.9)
            CR_init = random.uniform(0.5,0.9)
            ind = Individual(vec, perm, F_init, CR_init)
            self.individuals.append(ind)

    def bound_handling(self, vec):
        # فرض: محدودیت ها بین [0, total_ops-1]
        new_vec = []
        for x in vec:
            if x < 0 or x > self.instance.total_ops - 1:
                x = random.uniform(0, self.instance.total_ops - 1)
            new_vec.append(x)
        return new_vec

    def repair(self, float_vec):
        # با مرتب سازی بر اساس مقدار float_vec، توالی را می سازیم
        n, m = self.instance.n, self.instance.m
        t = n*m
        sorted_indices = sorted(range(t), key=lambda x: float_vec[x])
        # حالا با توجه به sorted_indices که ترتیب عملیات‌ها را مشخص می‌کند،
        # permutation ساخته می‌شود
        sel = [[False]*m for _ in range(n)]
        perm = []
        for idx in sorted_indices:
            j = idx // m
            o = idx % m
            if not sel[j][o]:
                perm.append((j, o))
                sel[j][o] = True
        # پرموتیشن کامل شده است
        return perm[:t]

    def evaluate(self):
        for ind in self.individuals:
            ind.makespan = self.calculate_makespan(ind.permutation)

    def calculate_makespan(self, permutation):
        jobs = self.instance.jobs
        n, m = self.instance.n, self.instance.m
        machine_count = max(op[0] for job in jobs for op in job)+1
        machine_time = [0]*machine_count
        job_time = [0]*n
        for j, o in permutation:
            mm, d = jobs[j][o]
            start = max(job_time[j], machine_time[mm])
            end = start + d
            job_time[j] = end
            machine_time[mm] = end
        return max(job_time)

    def truncated_normal(self, mean, sigma, lower, upper):
        while True:
            val = random.gauss(mean, sigma)
            if lower <= val <= upper:
                return val

    def run_generation(self):
        self.evaluate()
        sorted_pop = sorted(self.individuals, key=lambda x: x.makespan)
        half = self.size // 2
        better = sorted_pop[:half]
        worse = sorted_pop[half:]
        parent_pop = self.individuals
        new_pop = []
        F_values_success = []
        CR_values_success = []
        for i, parent in enumerate(parent_pop):
            F = self.truncated_normal(self.F_mean, 0.1, 0, 2)
            CR = self.truncated_normal(self.CR_mean, 0.1, 0, 1)
            rank_i = sorted_pop.index(parent)
            is_better = (rank_i < half)

            if self.process_type == 1:
                trial_vec = self.create_offspring_process1(parent, better, worse, F, CR, is_better)
            else:
                trial_vec = self.create_offspring_process2(parent, better, worse, F, CR, is_better)

            trial_vec = self.bound_handling(trial_vec)
            trial_perm = self.repair(trial_vec)
            trial_ind = Individual(trial_vec, trial_perm, F, CR)
            trial_ind.makespan = self.calculate_makespan(trial_perm)
            if trial_ind.makespan < parent.makespan:
                self.archive.add(parent.float_vec)
                new_pop.append(trial_ind)
                F_values_success.append(F)
                CR_values_success.append(CR)
            else:
                new_pop.append(parent)
        self.individuals = new_pop
        if len(F_values_success) > 0:
            self.F_mean = 0.9*self.F_mean + 0.1*(sum(F_values_success)/len(F_values_success))
        if len(CR_values_success) > 0:
            self.CR_mean = 0.9*self.CR_mean + 0.1*(sum(CR_values_success)/len(CR_values_success))

    def select_distinct_individuals(self, population, count, exclude=None):
        # انتخاب افراد مجزا از population بدون تکرار
        # اگر exclude تعیین شد، آن فرد را از جمعیت خارج کنید
        candidates = population if exclude is None else [p for p in population if p is not exclude]
        if len(candidates) < count:
            # اگر جمعیت کافی نداریم، با وجود این که در مسئله نباید این اتفاق بیفتد
            # می‌توان از fallback استفاده کرد
            return random.sample(population, count)
        return random.sample(candidates, count)

    def create_offspring_process1(self, parent, better, worse, F, CR, is_better):
        # Process 1 مطابق فرمول های (5)-(8)
        parent_vec = parent.float_vec
        n = self.instance.total_ops
        j_rand = random.randint(0, n-1)

        if is_better:
            # بخش بهتر: فرمول (5) و عملگر تقاطع (6)
            # V_i,G+1 = X_wr1,G + F(X_br1,G - X_br2,G)
            wr1 = self.select_distinct_individuals(worse, 1, exclude=parent)[0]
            # انتخاب br1, br2 از بهترها
            br1, br2 = self.select_distinct_individuals(better, 2, exclude=wr1)
            V = [wr1.float_vec[k] + F*(br1.float_vec[k]-br2.float_vec[k]) for k in range(n)]

            # بررسی f(V) و f(X) برای عملگر تقاطع (6)
            # if f(V) ≤ f(X) or r(j) ≥ CR or j=j_rand ==> V_j else X_j
            V_perm = self.repair(self.bound_handling(V))
            V_fit = self.calculate_makespan(V_perm)
            X_fit = parent.makespan
            trial = []
            for j in range(n):
                rj = random.random()
                if (V_fit <= X_fit) or (rj >= CR) or (j == j_rand):
                    trial.append(V[j])
                else:
                    trial.append(parent_vec[j])
            return trial
        else:
            # بخش بدتر: فرمول (7) و عملگر تقاطع (8)
            # V_i,G+1 = X_br1,G + F(X_wr1,G - X_wr2,G)
            br1 = self.select_distinct_individuals(better, 1, exclude=parent)[0]
            wr1, wr2 = self.select_distinct_individuals(worse, 2, exclude=br1)
            V = [br1.float_vec[k] + F*(wr1.float_vec[k]-wr2.float_vec[k]) for k in range(n)]

            # عملگر تقاطع (8)
            # if r(j) ≤ CR or j=j_rand ==> V_j else X_j
            trial = []
            for j in range(n):
                rj = random.random()
                if (rj <= CR) or (j == j_rand):
                    trial.append(V[j])
                else:
                    trial.append(parent_vec[j])
            return trial

    def create_offspring_process2(self, parent, better, worse, F, CR, is_better):
        # Process 2 مطابق فرمول های (9)-(12)
        parent_vec = parent.float_vec
        n = self.instance.total_ops
        j_rand = random.randint(0, n-1)

        if is_better:
            # بخش بهتر: فرمول (9) و عملگر تقاطع (10)
            # V_i,G+1 = X_wr1,G + F(X_wr1,G - X_br2,G)
            # توجه: در پروپوزال نوشته شده است که در فرآیند دوم
            # استراتژی شبیه current-best است اما توضیحات قبلی حفظ می‌کنیم
            # با توجه به پروپوزال:
            # V_i,G+1 = X_wr1,G + F(wr1 - br2)
            wr1 = self.select_distinct_individuals(worse, 1, exclude=parent)[0]
            br2 = self.select_distinct_individuals(better, 1, exclude=wr1)[0]

            # بر اساس پروپوزال در فرآیند دوم: (9)
            # : مطابق پروپوزال
            # DE/current-to-best/1/bin
            # فرض: طبق متن برای فرآیند دوم می‌خواهیم از یک بردار بهتر و یک بدتر استفاده کنیم:
            # V = X_wr1,G + F(X_wr1,G - X_br2,G)
            # برای جلوگیری از ابهام، از همان منطق کاربر با توجه به توضیح استفاده می‌کنیم
            V = [wr1.float_vec[k] + F*(wr1.float_vec[k]-br2.float_vec[k]) for k in range(n)]

            # عملگر تقاطع (10)
            # if f(V) ≤ f(X) or r(j)≥ CR or j=j_rand ==> V_j else X_j
            V_perm = self.repair(self.bound_handling(V))
            V_fit = self.calculate_makespan(V_perm)
            X_fit = parent.makespan
            trial = []
            for j in range(n):
                rj = random.random()
                if (V_fit <= X_fit) or (rj >= CR) or (j == j_rand):
                    trial.append(V[j])
                else:
                    trial.append(parent_vec[j])
            return trial
        else:
            # بخش بدتر: فرمول (11) و عملگر تقاطع (12)
            # V_i,G+1 = X_br1,G + F(X_wr1,G - X_wr2,G)
            br1 = self.select_distinct_individuals(better, 1, exclude=parent)[0]
            wr1, wr2 = self.select_distinct_individuals(worse, 2, exclude=br1)
            V = [br1.float_vec[k] + F*(wr1.float_vec[k]-wr2.float_vec[k]) for k in range(n)]

            # عملگر تقاطع (12)
            # if r(j) ≤ CR or j=j_rand ==> V_j else X_j
            trial = []
            for j in range(n):
                rj = random.random()
                if (rj <= CR) or (j == j_rand):
                    trial.append(V[j])
                else:
                    trial.append(parent_vec[j])
            return trial


def run_algorithm(process_type, instance, NP=100, G_max=50, runs=30):
    best_results = []
    for _ in range(runs):
        pop = IMDEPopulation(NP, instance, process_type=process_type, p_rate=0.1)
        no_improve_count = 0
        best_global = float('inf')
        for _g in range(G_max):
            pop.run_generation()
            pop.evaluate()
            current_best = min(pop.individuals, key=lambda x: x.makespan).makespan
            if current_best < best_global:
                best_global = current_best
                no_improve_count = 0
            else:
                no_improve_count += 1
        best = min(pop.individuals, key=lambda x: x.makespan)
        best_results.append(best.makespan)
    avg = statistics.mean(best_results)
    std = statistics.pstdev(best_results) if len(best_results)>1 else 0.0
    return avg, std, best_results

import time
import csv

if __name__ == "__main__":
    # افزودن همه داده‌ها
    datasets = ["ft06.txt", "la01.txt", "ft10.txt", "la16.txt", "abz5.txt"]
    runs = 50  # تعداد اجرای هر پیکربندی
    G_max = 50  # تعداد نسل‌ها
    NP = 200  # اندازه جمعیت
    results_summary = []

    for dataset in datasets:
        print(f"Running IMDE for dataset: {dataset}")
        instance = JSSPInstance(dataset)

        # فرآیند 1
        start_time = time.time()
        p1_avg, p1_std, p1_data = run_algorithm(process_type=1, instance=instance, NP=NP, G_max=G_max, runs=runs)
        p1_time = time.time() - start_time
        print(f"Process 1 (dataset: {dataset}) - Avg: {p1_avg}, Std: {p1_std}, Time: {p1_time:.2f}s")

        # فرآیند 2
        start_time = time.time()
        p2_avg, p2_std, p2_data = run_algorithm(process_type=2, instance=instance, NP=NP, G_max=G_max, runs=runs)
        p2_time = time.time() - start_time
        print(f"Process 2 (dataset: {dataset}) - Avg: {p2_avg}, Std: {p2_std}, Time: {p2_time:.2f}s")

        # محاسبه بهبود
        improvement_avg = ((p1_avg - p2_avg) / p1_avg) * 100 if p1_avg != 0 else 0
        print(f"Improvement in Process 2 over Process 1: {improvement_avg:.2f}%")

        # ذخیره نتایج در جدول خلاصه
        results_summary.append({
            "Dataset": dataset,
            "Process 1 Avg": p1_avg,
            "Process 1 Std": p1_std,
            "Process 1 Time": p1_time,
            "Process 2 Avg": p2_avg,
            "Process 2 Std": p2_std,
            "Process 2 Time": p2_time,
            "Improvement %": improvement_avg
        })

    # چاپ خلاصه نهایی
    print("\nFinal Summary of Results:")
    for result in results_summary:
        print(result)

    # ذخیره نتایج در فایل CSV
    with open("results_summary.csv", "w", newline='') as csvfile:
        fieldnames = ["Dataset", "Process 1 Avg", "Process 1 Std", "Process 1 Time",
                      "Process 2 Avg", "Process 2 Std", "Process 2 Time", "Improvement %"]
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()
        for result in results_summary:
            writer.writerow(result)

    # ذخیره نتایج به صورت متن
    with open("results_summary.txt", "w") as f:
        for result in results_summary:
            f.write(str(result) + "\n")

    print("\nResults saved to 'results_summary.csv' and 'results_summary.txt'.")